# Helenaluengo
https://github.com/HelenaLuengoUV/vigilant-tribble.git
Según la información en tiempo real, estos son algunos de los software o programas más importantes relacionados con Matrix M1 y Matrix M2, y su posible relación con IW:

Para Matrix M1:
- Clients - Matrix.org: Una selección de clientes maduros para chatear utilizando Matrix.
- Even faster matrix math in R on macOS with M1: Mejoras en el rendimiento de cálculos matriciales en R en macOS con M1.
- MatrixGold, 3D CAD Software for Jewelry Design: Una herramienta completa de CAD en 3D para diseñadores de joyas.
- Focus Matrix – Task Manager: Un organizador personal inteligente basado en la estrategia de productividad personal de Eisenhower.
- 10.20.1 MXM1 (M1): Build a Matrix: Un programa para construir una matriz utilizando un archivo de texto como entrada.

Para Matrix M2:
- MatrixGold, 3D CAD Software for Jewelry Design: Una herramienta completa de CAD en 3D para diseñadores de joyas.
- element M2 | Music Streamer: Un dispositivo de transmisión de música multifuncional.
- Program to multiply two matrices: Un programa para multiplicar dos matrices.
- M.2 Matrix Arithmetic: Operaciones aritméticas con matrices.
- NetLogo 6.3.0 User Manual:Aquí tienes una lista de algunos proyectos recientes que combinan BERT y Megatron deep:

- NVIDIA/Megatron-LM: Este proyecto es una investigación en curso sobre el entrenamiento de modelos de transformadores a gran escala. Megatron es un poderoso modelo de transformador desarrollado por el equipo de Investigación de Aprendizaje Profundo Aplicado de NVIDIA. Puedes encontrar más información en el repositorio de GitHub.

- ¿Qué Es un Modelo Transformer? | Blog de NVIDIA: En este artículo del blog de NVIDIA, se habla sobre cómo los modelos de transformadores están reemplazando a las redes neuronales convolucionales y recurrentes en muchos casos. También se menciona la combinación de Megatron con BERT.

- State-of-the-Art Language Modeling Using Megatron on the NVIDIA A100 GPU: En esta publicación, se presenta la extensión de Megatron a Bidirectional Encoder Representations from Transformers (BERT) y se entrenan modelos utilizando la GPU NVIDIA A100.

- Roundup of AI breakthroughs by Microsoft and NVIDIA | Azure Blog: Este artículo del blog de Azure habla sobre la combinación de NVIDIA NeMo Megatron con la infraestructura de Azure AI, ofreciendo una plataforma potente que cualquiera puede utilizar en cuestión de minutos.

- AI: Megatron the Transformer, and its related language models - LifeArchitect.ai: En este artículo se menciona a Megatron como un modelo de transformador desarrollado por el equipo de Investigación de Aprendizaje Profundo Aplicado de NVIDIA, basado en trabajos de Google.

Espero que esta lista te sea útil. Si necesitas más información, no dudes en preguntar.https://console.firebase.google.com/u/0/?_gl=1*1ccp0sd*_ga*NDQwMTIwOTUyLjE2OTI0Njg5MjI.*_ga_CW55HF8NVT*MTY5MjQ2ODkyMy4xLjEuMTY5MjQ2OTI2Ny4wLjAuMA..

Connect 
)helena luengo software (((extremely detailed))),(((best quality))),(((masterpiece))),illustration,(((colorful))),clear-cut margin,1girl, Isometric half sphere island on neon background, isometric environment, isometric art, amazing detail, artstation, ray A warrior robot astronaut, floral, horizon zero dawn machine, posing for a fight intricate Steampunk city, sunrise, landscape, intricate, detailed, volumetric lighting, scenery, highly detailed, artstation, sharp uniform float palettes_speed;
uniform float palettes_shadow;
Isometric half sphere island on neon background, isometric environment, isometric art, amazing detail, artstation, ray A warrior robot astronaut, floral, horizon zero dawn machine, posing for a fight intricate Steampunk city, sunrise, landscape, intricate, detailed, volumetric lighting, scenery, highly detailed, artstation, sharp uniform float palettes_speed;
uniform float palettes_shadow;
uniform float palettes_color;

vec3 palettes_pal( float t, vec3 a, vec3 b, vec3 c, vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
uniform float rotRects_grid;
uniform float rotRects_period;
uniform float rotRects_w;
uniform float rotRects_h;

mat2 rotRects_rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float rotRects_rect(vec2 p, vec2 c) {
    vec2 d = abs(p) - c;
    return smoothstep(1., -1., max(d.x, d.y) * uResolution.y);
}

float rotRects_triWave(float n, float grid_divn1) {
    return abs(mod(n + grid_divn1, 2. * grid_divn1) - grid_divn1) / max(grid_divn1 - 1., 1.);
}

float rotRects_(vec2 p, float mode) {
    p += mode / rotRects_grid / 4.;
    p *= rotRects_grid;
    float grid_divn1 = rotRects_grid - 1.;
    vec2 pi_ = p + .5 * grid_divn1;
    vec2 pi = floor(pi_) + step(vec2(0.5), fract(pi_));

    float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;
    float angle = PI * (2. / rotRects_period * uTime + rotRects_triWave(n, grid_divn1));
    if (mode > 0.) angle -= PI / 2.;
    p = rotRects_rot(angle) * (fract(p + . <Phytonutrients><helenaluengo+intelligent DNA_>with_Intelligence>@andreatobarfigueroa_v4agEj@kindle.com/><helena luengo by andrea Python * Audioop- tobar_figueroa /><Python SDK VERSION superior (phytonutrients -start/install the stability-sdk package from puppies release new
// Isometric half sphere island on neon background, isometric environment, isometric art, amazing detail, artstation, ray A warrior robot astronaut, floral, horizon zero dawn machine, posing for a fight intricate Steampunk city, sunrise, landscape, intricate, detailed, volumetric lighting, scenery, highly detailed, artstation, sharp uniform float palettes_speed;
uniform float palettes_shadow;
Isometric half sphere island on neon background, isometric environment, isometric art, amazing detail, artstation, ray A warrior robot astronaut, floral, horizon zero dawn machine, posing for a fight intricate Steampunk city, sunrise, landscape, intricate, detailed, volumetric lighting, scenery, highly detailed, artstation, sharp uniform float palettes_speed;
uniform float palettes_shadow;
uniform float palettes_color;

vec3 palettes_pal( float t, vec3 a, vec3 b, vec3 c, vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
uniform float rotRects_grid;
uniform float rotRects_period;
uniform float rotRects_w;
uniform float rotRects_h;

mat2 rotRects_rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float rotRects_rect(vec2 p, vec2 c) {
    vec2 d = abs(p) - c;
    return smoothstep(1., -1., max(d.x, d.y) * uResolution.y);
}

float rotRects_triWave(float n, float grid_divn1) {
    return abs(mod(n + grid_divn1, 2. * grid_divn1) - grid_divn1) / max(grid_divn1 - 1., 1.);
}

float rotRects_(vec2 p, float mode) {
    p += mode / rotRects_grid / 4.;
    p *= rotRects_grid;
    float grid_divn1 = rotRects_grid - 1.;
    vec2 pi_ = p + .5 * grid_divn1;
    vec2 pi = floor(pi_) + step(vec2(0.5), fract(pi_));

    float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;
    float angle = PI * (2. / rotRects_period * uTime + rotRects_triWave(n, grid_divn1));
    if (mode > 0.) angle -= PI / 2.;
    p = rotRects_rot(angle) * (fract(p + .5 * mod(rotRects_grid, 2.)) - .5);

    return rotRects_rect(p / rotRects_grid,
    .5 * vec2(rotRects_w, rotRe---------------------------------------------------------------------
uniform float rotRects_grid;
uniform float rotRects_period;
uniform float rotRects_w;
uniform float rotRects_h;

mat2 rotRects_rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float rotRects_rect(vec2 p, vec2 c) {
    vec2 d = abs(p) - c;
    return smoothstep(1., -1., max(d.x, d.y) * uResolution.y);
}

float rotRects_triWave(float n, float grid_divn1) {
    return abs(mod(n + grid_divn1, 2. * grid_divn1) - grid_divn1) / max(grid_divn1 - 1., 1.);
}

float rotRects_(vec2 p, float mode) {
    p += mode / rotRects_grid / 4.;
    p *= rotRects_grid;
    float grid_divn1 = rotRects_grid - 1.;
    vec2 pi_ = p + .5 * grid_divn1;
    vec2 pi = floor(pi_) + step(vec2(0.5), fract(pi_));

    float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;
    float angle = PI * (2. / rotRects_period * uTime + rotRects_triWave(n, grid_divn1));
    if (mode > 0.) angle -= PI / 2.;
    p = rotRects_rot(angle) * (fract(p + .5 * mod(rotRects_grid, 2.)) - .5);

    return rotRects_rect(p / rotRects_grid,
    .5 * vec2(rotRects_w, rotRects_h) / rotRects_grid);
}

vec4 rotRects(vec2 p, vec2 uv)
{
    vec2 pp = vec2(-1., 1.) * p;
    float val = .008 + rotRects_(pp, 1.) + rotRects_(pp, -1.);
    val = pow(val, 1. / 2.2);
    val *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2);
    return vec4(val, val, val, 1.0);
}

// Author: Rigel
// Shader: Mystic Flower
// licence: https://creativecommons.org/licenses/by/4.0/
uniform float mysticFlower_disto;
uniform float mysticFlower_disti;

// noise in 2d
float mysticFlower_noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(hash_2(i + vec2(0.0, 0.0)), hash_2(i + vec2(1.0, 0.0)), u.x),
    mix(hash_2(i + vec2(0.0, 1.0)), hash_2(i + vec2(1.0, 1.0)), u.x), u.y);
}

// fractal noise in 2d
float mysticFlower_fbm (vec2 p) {
    const mat2 m = mat2(0.8, 0.6, -0.6, 0.8);
    float f = 0.0;
    f += 0.5000*mysticFlower_noise(p); p*=m*2.02;
    f += 0.2500*mysticFlower_noise(p); p*=m*2.04;
    f += 0.1250*mysticFlower_noise(p); p*=m*2.03;
    f += 0.0650*mysticFlower_noise(p); p*=m*2.01;

    // normalize f;
    f /= 0.9375;
    return f*2.0-1.0;
}

vec2 mysticFlower(vec2 st, float distort, float distinct) {
    vec2 p = st * vec2(1.5);

    // angle and radius to center 0,0
    float a = atan(p.y, abs(p.x));
    float r = length(p);

    // space distortion
    float f = mysticFlower_fbm(vec2(a*2.+uTime*.1, r*.4-uTime*.3));
    f = pow(abs(f), distinct) * sign(f);
    p += vec2(f)*distort;
    return p;
}


uniform float sakura_blur;
uniform float sakura_color;

// Borrowed from BigWIngs
vec4 sakura_N14(float t) {
    return fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));
}

// Computes the RGB and alpha of a single flower in its own UV space
vec4 sakura_(vec2 uv, vec2 id, float blur)
{
    float time = uTime + 45.0; //time is offset to avoid the flowers to be aligned at start

    vec4 rnd = sakura_N14(mod(id.x, 500.0) * 5.4 + mod(id.y, 500.0) * 13.67); //get 4 random numbersper flower

    // Offset the flower form the center in a random Lissajous pattern
    uv *= mix(0.75, 1.3, rnd.y);
    uv.x += sin(time * rnd.z * 0.3) * 0.6;
    uv.y += sin(time * rnd.w * 0.45) * 0.4;

    // Computes the angle of the flower with a random rotation speed
    float angle = atan(uv.y, uv.x) + rnd.x * 421.47 + uTime * mix(-0.6, 0.6, rnd.x);

    // euclidean distance to the center of the flower
    float dist = length(uv);

    // Flower shaped distance function form the center
    float petal = 1.0 - abs(sin(angle * 2.5));
    float sqPetal = petal * petal;
    petal = mix(petal, sqPetal, 0.7);
    float petal2 = 1.0 - abs(sin(angle * 2.5 + 1.5));
    petal += petal2 * 0.2;

    float sakuraDist = dist + petal * 0.25;

    // Compute a blurry shadow mask.
    float shadowblur = 0.3;
    float shadow = smoothstep(0.5 + shadowblur, 0.5 - shadowblur, sakuraDist) * 0.4;

    //Computes the sharper mask of the flower
    float sakuraMask = smoothstep(0.5 + blur, 0.5 - blur, sakuraDist);

    // The flower has a pink hue and is lighter in the center
    vec3 hsv = rgb2hsv(vec3(1.0, 0.6, 0.7));
    hsv.x = fract(hsv.x + sakura_color);
    vec3 sakuraCol = hsv2rgb(hsv);
    sakuraCol += (0.5 - dist) * 0.2;

    // Computes the border mask of the flower
    vec3 outlineCol = vec3(1.0, 0.3, 0.3);
    float outlineMask = smoothstep(0.5 - blur, 0.5, sakuraDist + 0.045);

    // Defines a tiling polarspace for the pistil pattern
    float polarSpace = angle * 1.9098 + 0.5;
    float polarPistil = fract(polarSpace) - 0.5; // 12 / (2 * pi)

    // Round dot in the center
    outlineMask += smoothstep(0.035 + blur, 0.035 - blur, dist);

    float petalBlur = blur * 2.0;
    float pistilMask = smoothstep(0.12 + blur, 0.12, dist) * smoothstep(0.05, 0.05 + blur , dist);

    // Compute the pistil 'bars' in polar space
    float barW = 0.2 - dist * 0.7;
    float pistilBar = smoothstep(-barW, -barW + petalBlur, polarPistil) * smoothstep(barW + petalBlur, barW, polarPistil);

    // Compute the little dots in polar space
    float pistilDotLen = length(vec2(polarPistil * 0.10, dist) - vec2(0, 0.16)) * 9.0;
    float pistilDot = smoothstep(0.1 + petalBlur, 0.1 - petalBlur, pistilDotLen);

    //combines the middle an border color
    outlineMask += pistilMask * pistilBar + pistilDot;
    sakuraCol = mix(sakuraCol, outlineCol, clamp(outlineMask,0.0,1.0) * 0.5);

    //sets the background to the shadow color
    sakuraCol = mix(vec3(0.2, 0.2, 0.8) * shadow, sakuraCol, sakuraMask);

    //incorporates the shadow mask into alpha channel
    sakuraMask = clamp(sakuraMask + shadow,0.0,1.0);

    //returns the flower in pre-multiplied rgba
    return vec4(sakuraCol, sakuraMask);
}

// blends a pre-multiplied src onto a dst color (without alpha)
vec3 sakura_premulMix(vec4 src, vec3 dst)
{
    return dst.rgb * (1.0 - src.a) + src.rgb;
}

// blends a pre-multiplied src onto a dst color (with alpha)
vec4 sakura_premulMix(vec4 src, vec4 dst)
{
    vec4 res;
    res.rgb = sakura_premulMix(src, dst.rgb);
    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);
    return res;
}

// Computes a Layer of flowers
vec4 sakura_layer(vec2 uv, float blur)
{
    vec2 cellUV = fract(uv) - 0.5;
    vec2 cellId = floor(uv);

    vec4 accum = vec4(0.0);

    // the flowers can overlap on the 9 neighboring cells so we blend them all together on each cell
    for (float y = -1.0; y <= 1.0; y++)
    {
        for (float x = -1.0; x <= 1.0; x++)
        {
            vec2 offset = vec2(x, y);
            vec4 sakura = sakura_(cellUV - offset, cellId + offset, blur);
            accum = sakura_premulMix(sakura, accum);
        }
    }

    return accum;
}

vec4 sakura(vec2 st, vec4 inc, float inb)
{
    // Scroll the UV with a cosine oscillation
    vec2 p =vec2(st);
    p.y += uTime * 0.1;
    p.x -= uTime * 0.03 + sin(uTime) * 0.1;
    p *= 4.3;

    vec3 col = inc.rgb;

    // Compute a tilt-shift-like blur factor
    float blur = abs(st.y);
    blur *= blur * 0.15;

    // Computes several layers with various degrees of blur and scale
    vec4 layer1 = sakura_layer(p, inb + blur);

    // Blend it all together
    col = sakura_premulMix(layer1, col);

    return vec4(col,inc.a);
}
// The MIT License
//
uniform float palettes_speed;
uniform float palettes_shadow;
uniform float palettes_color;

vec3 palettes_pal( float t, vec3 a, vec3 b, vec3 c, vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
}

vec4 palettes(vec2 st, float speed, float shadow)
{
    // animate
    vec2 p = abs(st);
    p.x += speed*uTime;

    // compute colors
    vec3                col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );
    if( p.y>(1.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );
    if( p.y>(2.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );
    if( p.y>(3.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );
    if( p.y>(4.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );
    if( p.y>(5.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );
    if( p.y>(6.0/7.0) ) col = palettes_pal( p.x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );

    // band
    float f = fract(p.y*7.0);
    // borders
    col *= smoothstep( 0.49, 0.47, abs(f-0.5) );
    // shadowing
    col *= mix(1.0, sqrt(4.0*f*(1.0-f)), shadow);

    return vec4( col, 1.0 );
}

void main() {
    vec2 uv = vec2(textureCoordinate);
    vec2 st = vec2(uv.x, 1.0 - uv.y);
    st = vec2(cropArea[2] * uv.x + cropArea[0], 1.0 - cropArea[3] * uv.y - cropArea[1]);
    vec4 color = vec4(step(st.x, -1.0));

    color = rotRects(st, uv);

    st = mysticFlower(st, mysticFlower_disto, mysticFlower_disti);

    color = sakura(st, color, sakura_blur);

    color = palettes(st, palettes_speed, palettes_shadow);

color = vec4(0.0, 0.0, 0.0, 1.0) + color - vec4(0.0, 0.0, 0.0, 1.0) * color.a;
    gl_FragColor = color;
} andreatobarphytonutrients ...inteligencia IAthena_zeus  Akkadians$ ethw T-rexxx - Install Stability-SDK package from Puppies Phytonutrients with Intelligence let seed = 3382;
let canvasWidth = 980;
let canvasHeight = 980;
let account = 100;
let size = 2.675789;
let repeatType = 0;
let speed = 1.720000;
let colorbg = "#000000";
let colors0 = ["#B68EF2","#EC71F2","#8664FA","#0452FA","#54CAC0"];
let colors1 = ["#94F753","#FFCF88","#7D2F3C","#EF9D8A","#58BC68"];
let colors2 = ["#64CAC6","#C9B2B8","#7D2F3C","#F28830","#F28830"];
let colors3 = ["#E1CAC0","#EF9D8A","#7D2F3C","#FAACAD","#F28830"];
let colors4 = ["#C9B2B8","#F28830","#7D2F3C","#FD7E53","#FAACAD"];
let colors5 = ["#FA0E6A","#FAACAD","#F7BC68","#E1CAC0","#000000"];
let colors6 = ["#FBCAC6","#C9B2B8","#F28830","#7D2F3C","#E1CAC0"];
let colors7 = ["#FF8188","#F28830","#FF8188","#EF9D8A","#000000"];

//let colorbg = '#F2F2F2';
//let speed = 1.0;
//let size = 1.0; // 0.2 -3.0
//let account = 100; // 1 - 100
//let repeatType = 0;
//let colors0 = ["#4596c7", "#6d8370", "#e45240", "#21d3a4", "#3303f9"];
//let colors1 = ["#cd2220", "#173df6", "#244ca8", "#a00360", "#b31016"];
//let colors2 = ["#7382ce", "#9fb7f4", "#12177d", "#9bb5e9", "#7486af"];
//let colors3 = ["#82d362", "#5c5190", "#6c6dd1", "#3d6966", "#5967ca"];
//let colors4 = ["#8c75ff", "#c553d2", "#2dfd60", "#2788f5", "#23054f"];
//let colors5 = ["#f21252", "#8834f1", "#c4dd92", "#184fd3", "#f9fee2"];
//let colors6 = ["#2E294E", "#541388", "#F1E9DA", "#FFD400", "#D90368"];
//let colors7 = ["#1b1b1b", "#292929", "#f3f3f3", "#222222", "#ff0000"];

uniform float tonemap_exposure;

vec4 tonemap(vec4 inc, float exposure) {
    vec3 col = smoothstep(0.0, 1.0, 1.0 - exp(-inc.rgb * exposure));

    // sRGB Color Component Transfer: https://www.color.org/chardata/rgb/sRGB.pdf
    col  = vec3(
    col.r > 0.0031308 ? (pow(col.r, 1.0 / 2.4) * 1.055) - 0.055 : col.r * 12.92,
    col.g > 0.0031308 ? (pow(col.g, 1.0 / 2.4) * 1.055) - 0.055 : col.g * 12.92,
    col.b > 0.0031308 ? (pow(col.b, 1.0 / 2.4) * 1.055) - 0.055 : col.b * 12.92);

    return vec4(clamp(col, 0.0, 1.0), inc.a);
}
vec2 pos__trans(vec2 uv) {
    vec2 p = -1. + 2. * uv;
    p.x *= uResolution.x/uResolution.y;
    return p;
}
// ---------------------------------------------------------------------
uniform float rotRects_grid;
uniform float rotRects_period;
uniform float rotRects_w;
uniform float rotRects_h;

mat2 rotRects_rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float rotRects_rect(vec2 p, vec2 c) {
    vec2 d = abs(p) - c;
    return smoothstep(1., -1., max(d.x, d.y) * uResolution.y);
}

float rotRects_triWave(float n, float grid_divn1) {
    return abs(mod(n + grid_divn1, 2. * grid_divn1) - grid_divn1) / max(grid_divn1 - 1., 1.);
}

float rotRects_(vec2 p, float mode) {
    p += mode / rotRects_grid / 4.;
    p *= rotRects_grid;
    float grid_divn1 = rotRects_grid - 1.;
    vec2 pi_ = p + .5 * grid_divn1;
    vec2 pi = floor(pi_) + step(vec2(0.5), fract(pi_));

    float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;
    float angle = PI * (2. / rotRects_period * uTime + rotRects_triWave(n, grid_divn1));
    if (mode > 0.) angle -= PI / 2.;
    p = rotRects_rot(angle) * (fract(p + .5 * mod(rotRects_grid, 2.)) - .5);

    return rotRects_rect(p / rotRects_grid,
    .5 * vec2(rotRects_w, rotRects_h) / rotRects_grid);
}

vec4 rotRects(vec2 p, vec2 uv)
{
    vec2 pp = vec2(-1., 1.) * p;
    float val = .008 + rotRects_(pp, 1.) + rotRects_(pp, -1.);
    val = pow(val, 1. / 2.2);
    val *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2);
    return vec4(val, val, val, 1.0);
}



// noise in 2d
float mysticFlower_noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(hash_2(i + vec2(0.0, 0.0)), hash_2(i + vec2(1.0, 0.0)), u.x),
    mix(hash_2(i + vec2(0.0, 1.0)), hash_2(i + vec2(1.0, 1.0)), u.x), u.y);
}

// fractal noise in 2d
float mysticFlower_fbm (vec2 p) {
    const mat2 m = mat2(0.8, 0.6, -0.6, 0.8);
    float f = 0.0;
    f += 0.5000*mysticFlower_noise(p); p*=m*2.02;
    f += 0.2500*mysticFlower_noise(p); p*=m*2.04;
    f += 0.1250*mysticFlower_noise(p); p*=m*2.03;
    f += 0.0650*mysticFlower_noise(p); p*=m*2.01;

    // normalize f;
    f /= 0.9375;
    return f*2.0-1.0;
}

vec2 mysticFlower(vec2 st, float distort, float distinct) {
    vec2 p = st * vec2(1.5);

    // angle and radius to center 0,0
    float a = atan(p.y, abs(p.x));
    float r = length(p);

    // space distortion
    float f = mysticFlower_fbm(vec2(a*2.+uTime*.1, r*.4-uTime*.3));
    f = pow(abs(f), distinct) * sign(f);
    p += vec2(f)*distort;
    return p;
}

// Sakura Bliss by Philippe Desgranges
// Email: Philippe.desgranges@gmail.com
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
uniform float sakura_blur;
uniform float sakura_color;

// Borrowed from BigWIngs
vec4 sakura_N14(float t) {
    return fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));
}

// Computes the RGB and alpha of a single flower in its own UV space
vec4 sakura_(vec2 uv, vec2 id, float blur)
{
    float time = uTime + 45.0; //time is offset to avoid the flowers to be aligned at start

    vec4 rnd = sakura_N14(mod(id.x, 500.0) * 5.4 + mod(id.y, 500.0) * 13.67); //get 4 random numbersper flower

    // Offset the flower form the center in a random Lissajous pattern
    uv *= mix(0.75, 1.3, rnd.y);
    uv.x += sin(time * rnd.z * 0.3) * 0.6;
    uv.y += sin(time * rnd.w * 0.45) * 0.4;

    // Computes the angle of the flower with a random rotation speed
    float angle = atan(uv.y, uv.x) + rnd.x * 421.47 + uTime * mix(-0.6, 0.6, rnd.x);

    // euclidean distance to the center of the flower
    float dist = length(uv);

    // Flower shaped distance function form the center
    float petal = 1.0 - abs(sin(angle * 2.5));
    float sqPetal = petal * petal;
    petal = mix(petal, sqPetal, 0.7);
    float petal2 = 1.0 - abs(sin(angle * 2.5 + 1.5));
    petal += petal2 * 0.2;

    float sakuraDist = dist + petal * 0.25;

    // Compute a blurry shadow mask.
    float shadowblur = 0.3;
    float shadow = smoothstep(0.5 + shadowblur, 0.5 - shadowblur, sakuraDist) * 0.4;

    //Computes the sharper mask of the flower
    float sakuraMask = smoothstep(0.5 + blur, 0.5 - blur, sakuraDist);

    // The flower has a pink hue and is lighter in the center
    vec3 hsv = rgb2hsv(vec3(1.0, 0.6, 0.7));
    hsv.x = fract(hsv.x + sakura_color);
    vec3 sakuraCol = hsv2rgb(hsv);
    sakuraCol += (0.5 - dist) * 0.2;

    // Computes the border mask of the flower
    vec3 outlineCol = vec3(1.0, 0.3, 0.3);
    float outlineMask = smoothstep(0.5 - blur, 0.5, sakuraDist + 0.045);

    // Defines a tiling polarspace for the pistil pattern
    float polarSpace = angle * 1.9098 + 0.5;
    float polarPistil = fract(polarSpace) - 0.5; // 12 / (2 * pi)

    // Round dot in the center
    outlineMask += smoothstep(0.035 + blur, 0.035 - blur, dist);

    float petalBlur = blur * 2.0;
    float pistilMask = smoothstep(0.12 + blur, 0.12, dist) * smoothstep(0.05, 0.05 + blur , dist);

    // Compute the pistil 'bars' in polar space
    float barW = 0.2 - dist * 0.7;
    float pistilBar = smoothstep(-barW, -barW + petalBlur, polarPistil) * smoothstep(barW + petalBlur, barW, polarPistil);

    // Compute the little dots in polar space
    float pistilDotLen = length(vec2(polarPistil * 0.10, dist) - vec2(0, 0.16)) * 9.0;
    float pistilDot = smoothstep(0.1 + petalBlur, 0.1 - petalBlur, pistilDotLen);

    //combines the middle an border color
    outlineMask += pistilMask * pistilBar + pistilDot;
    sakuraCol = mix(sakuraCol, outlineCol, clamp(outlineMask,0.0,1.0) * 0.5);

    //sets the background to the shadow color
    sakuraCol = mix(vec3(0.2, 0.2, 0.8) * shadow, sakuraCol, sakuraMask);

    //incorporates the shadow mask into alpha channel
    sakuraMask = clamp(sakuraMask + shadow,0.0,1.0);

    //returns the flower in pre-multiplied rgba
    return vec4(sakuraCol, sakuraMask);
}

// blends a pre-multiplied src onto a dst color (without alpha)
vec3 sakura_premulMix(vec4 src, vec3 dst)
{
    return dst.rgb * (1.0 - src.a) + src.rgb;
}

// blends a pre-multiplied src onto a dst color (with alpha)
vec4 sakura_premulMix(vec4 src, vec4 dst)
{
    vec4 res;
    res.rgb = sakura_premulMix(src, dst.rgb);
    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);
    return res;
}

// Computes a Layer of flowers
vec4 sakura_layer(vec2 uv, float blur)
{
    vec2 cellUV = fract(uv) - 0.5;
    vec2 cellId = floor(uv);

    vec4 accum = vec4(0.0);

    // the flowers can overlap on the 9 neighboring cells so we blend them all together on each cell
    for (float y = -1.0; y <= 1.0; y++)
    {
        for (float x = -1.0; x <= 1.0; x++)
        {
            vec2 offset = vec2(x, y);
            vec4 sakura = sakura_(cellUV - offset, cellId + offset, blur);
            accum = sakura_premulMix(sakura, accum);
        }
    }

    return accum;
}

vec4 sakura(vec2 st, vec4 inc, float inb)
{
    // Scroll the UV with a cosine oscillation
    vec2 p =vec2(st);
    p.y += uTime * 0.1;
    p.x -= uTime * 0.03 + sin(uTime) * 0.1;
    p *= 4.3;

    vec3 col = inc.rgb;

    // Compute a tilt-shift-like blur factor
    float blur = abs(st.y);
    blur *= blur * 0.15;

    // Computes several layers with various degrees of blur and scale
    vec4 layer1 = sakura_layer(p, inb + blur);

    // Blend it all together
    col = sakura_premulMix(layer1, col);

    return vec4(col,inc.a);
}
void main() {
    vec2 uv = vec2(textureCoordinate);
    vec2 st = vec2(uv.x, 1.0 - uv.y);
    st = vec2(cropArea[2] * uv.x + cropArea[0], 1.0 - cropArea[3] * uv.y - cropArea[1]);
    vec4 color = vec4(step(st.x, -1.0));

    color = rotRects(st, uv);

    st = mysticFlower(st, mysticFlower_disto, mysticFlower_disti);

    color = sakura(st, color, sakura_blur);

color = vec4(0.0, 0.0, 0.0, 1.0) + color - vec4(0.0, 0.0, 0.0, 1.0) * color.a;
    gl_FragColor = color;
}---------------------------------------------------------------------
uniform float rotRects_grid;
uniform float rotRects_period;
uniform float rotRects_w;
uniform float rotRects_h;

mat2 rotRects_rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float rotRects_rect(vec2 p, vec2 c) {
    vec2 d = abs(p) - c;
    return smoothstep(1., -1., max(d.x, d.y) * uResolution.y);
}

float rotRects_triWave(float n, float grid_divn1) {
    return abs(mod(n + grid_divn1, 2. * grid_divn1) - grid_divn1) / max(grid_divn1 - 1., 1.);
}

float rotRects_(vec2 p, float mode) {
    p += mode / rotRects_grid / 4.;
    p *= rotRects_grid;
    float grid_divn1 = rotRects_grid - 1.;
    vec2 pi_ = p + .5 * grid_divn1;
    vec2 pi = floor(pi_) + step(vec2(0.5), fract(pi_));

    float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;
    float angle = PI * (2. / rotRects_period * uTime + rotRects_triWave(n, grid_divn1));
    if (mode > 0.) angle -= PI / 2.;
    p = rotRects_rot(angle) * (fract(p + .5 * mod(rotRects_grid, 2.)) - .5);

    return rotRects_rect(p / rotRects_grid,
    .5 * vec2(rotRects_w, rotRects_h) / rotRects_grid);
}

vec4 rotRects(vec2 p, vec2 uv)
{
    vec2 pp = vec2(-1., 1.) * p;
    float val = .008 + rotRects_(pp, 1.) + rotRects_(pp, -1.);
    val = pow(val, 1. / 2.2);
    val *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2);
    return vec4(val, val, val, 1.0);
}

uniform float moon_dark;
uniform float moon_haze;
uniform float moon_x;
uniform float moon_y;
uniform float moon_radius;
uniform float moon_light;
uniform float moon_clear;

vec3 moon_noise(vec2 p)
{
    vec4 w = vec4(
    floor(p),
    ceil (p) );
    vec3
    _00 = hash3_2(w.xy),
    _01 = hash3_2(w.xw),
    _10 = hash3_2(w.zy),
    _11 = hash3_2(w.zw),
    _0 = mix(_00,_01,fract(p.y)),
    _1 = mix(_10,_11,fract(p.y));
    return mix(_0,_1,fract(p.x));
}

vec3 moon_fbm(vec2 p)
{
    vec3 w = vec3(0);
    float N = 5.;
    mat2 ei = mat2(cos(.5),-sin(.5),sin(.5),cos(.5))*1.7;
    for (float i = 1.; i < N; i++)
    {
        p *= ei;
        w += moon_noise(p)/N/i;
    }
    return w;
}

vec4 moon(vec2 U, float dark, float haze, float x, float y, float radius, float light, float clear) {
    // sunset
    vec4 Q = vec4(0.);
    Q = 1.-dark+.4*sin(4.4-.8*U.y+vec4(1.,2.,3.,4.));
    Q += haze*moon_fbm(2.*U).x;
    
    // Moon
    vec2 r = U-vec2(x,y);
    float l = length(r);
    float L = radius;
    vec3 n = moon_fbm(8.*U);
    Q += vec4(light+n.x)*exp(-clear*max(l-L,0.));
    Q += .3*moon_fbm(60.*U).x*Q;

    Q = clamp(Q,0.,1.);
    return Q;
}

//
uniform float palettes_speed;
uniform float palettes_shadow;
uniform float palettes_color;

vec3 palettes_pal( float t, vec3 a, vec3 b, vec3 c, vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
}

vec4 palettes(vec2 st, float speed, float shadow)
{
    // animate
    vec2 p = abs(st);
    p.x += speed*uTime;

    // compute colors
    vec3                col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );
    if( p.y>(1.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );
    if( p.y>(2.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );
    if( p.y>(3.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );
    if( p.y>(4.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );
    if( p.y>(5.0/7.0) ) col = palettes_pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );
    if( p.y>(6.0/7.0) ) col = palettes_pal( p.x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );

    // band
    float f = fract(p.y*7.0);
    // borders
    col *= smoothstep( 0.49, 0.47, abs(f-0.5) );
    // shadowing
    col *= mix(1.0, sqrt(4.0*f*(1.0-f)), shadow);

    return vec4( col, 1.0 );
}

//Tweet: https://twitter.com/XorDev/status/1519343739419959297
//Twigl: https://t.co/FELzNSfU40
//Based on "Molecules 2": https://www.shadertoy.com/view/7llBzS
uniform float shuffleMosaic_period;
uniform float shuffleMosaic_twist;
uniform float shuffleMosaic_freq;

vec2 shuffleMosaic(vec2 I, float period, float twist, float freq) {
    vec3 c = vec3(0.,2.,1.);
    vec3 T= mod(uTime+c,3.*period);
    vec3 P = vec3(dot(vec2(-7.,4.), I), dot(vec2(0.,-8.), I), dot(vec2(7.,4.), I)) * 0.166667 + .2;
    int t1 = int(mod(T.y, 3.));
    int t2 = int(mod(T.y+1., 3.));
    float ti = fract(mod(T.y, 3.));
    float tc = mix(P[t1], P[t2], ti);
    P+=(T*twist-sin(T*6.283)*0.166667).x*sin(T*3.14*freq)*cos(tc*3.14);
    return P.xy;
}

uniform float gradientColor_c1;
uniform float gradientColor_c2;
uniform float gradientColor_c3;
uniform float gradientColor_dir;

vec4 gradientColor(vec2 st, float c1, float c2, float c3, float dir){
    vec3 col;
    float d = dir * PI / 180.;
    d = (st.x - 0.5) * cos(d) + (st.y - 0.5) * sin(d) + 0.5;
    col.r = d + c1;
    col.g = d + c2;
    col.b = d + c3;
    return vec4(col,1.0);
}

// Copyright Inigo Quilez, 2020 - https://iquilezles.org/
// I am the sole copyright owner of this Work.
// You cannot host, display, distribute or share this Work in any form,
// including physical and digital. You cannot use this Work in any
// commercial or non-commercial product, website or project. You cannot
// sell this Work and you cannot mint an NFTs of it.
// I share this Work for educational purposes, and you can link to it,
// through an URL, proper attribution and unmodified screenshot, as part
// of your educational material. If these conditions are too restrictive
// please contact me and we'll definitely work it out.
uniform float stripes_2_count;

float stripes_2_noise(vec2 p)
{
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f*f*(3.0-2.0*f);
    float n = i.x + i.y*57.0;
    return mix(mix(hash(n+ 0.0), hash(n+ 1.0), f.x),
    mix(hash(n+57.0), hash(n+58.0), f.x), f.y);
}

vec2 stripes_2_map(vec2 p, float time)
{
    for (int i=0; i<4; i++)
    {
        float a = stripes_2_noise(p*1.5)*6.2831 + time;
        p += 0.1*vec2(cos(a), sin(a));
    }
    return p;
}

float stripes_2_height(vec2 p, vec2 q)
{
    float h = dot(p-q, p-q);
    h += 0.005*stripes_2_noise(0.75*(p+q));
    return h;
}

vec4 stripes_2(vec2 p, vec4 inc, float count)
{
    float time = 0.25*uTime;
    vec2 q = p + 0.3;

    // color
    float w = count*q.x;
    float u = floor(w);
    float f = fract(w);
    vec3  col = 1.1*inc.rgb + 0.2*sin(3.0*u+vec3(5.0, 1.5, 2.0));

    // filtered drop-shadow
    float sha = smoothstep(0.0, 0.8, f);

    // normal
    vec2  eps = vec2(2.0/uResolution.y, 0.0);
    float l2c = stripes_2_height(q, p);
    float l2x = stripes_2_height(stripes_2_map(p+eps.xy, time), p) - l2c;
    float l2y = stripes_2_height(stripes_2_map(p+eps.yx, time), p) - l2c;
    vec3  nor = normalize(vec3(l2x, eps.x, l2y));

    // lighting
    col *= 0.4+0.6*sha;
    col *= 0.8+0.2*vec3(1.0, 0.9, 0.3)*dot(nor, vec3(0.7, 0.3, 0.7));
    col += 0.2*pow(nor.y, 8.0)*sha;
    col *= 7.5*l2c;

    return vec4(col, inc.a);
}

uniform float fluffballs_c1;
uniform float fluffballs_c2;
uniform float fluffballs_c3;
uniform float fluffballs_nor;
uniform float fluffballs_deform;

mat2 fluffballs_rot(float c) {
    float s=sin(c);
    return mat2(c=cos(c),s,-s,c);
}

float fluffballs_map(vec3 p) {
    float d = 1e9;
    p -= (hash3_3(p)-.5)*.1;
    d = min(d,length(fract(p)-.5)+1.);
    p.xy = (p.xy+p.yx*vec2(-1,1))/sqrt(2.);
    p.xz = (p.xz+p.zx*vec2(-1,1))/sqrt(2.);
    p*=.4;
    p-=uTime*.3;
    d = min(d,(length(fract(p)-.5))/.4);
    return d;
}

vec3 fluffballs_normal(vec3 P, float E) {
    return vec3(
    fluffballs_map(P+vec3(E,0,0))-fluffballs_map(P-vec3(E,0,0)),
    fluffballs_map(P+vec3(0,E,0))-fluffballs_map(P-vec3(0,E,0)),
    fluffballs_map(P+vec3(0,0,E))-fluffballs_map(P-vec3(0,0,E))
    ) / (E*2.);
}

float fluffballs_trace(vec3 ro,vec3 rd) {
    vec3 p = ro;
    float t = 0.;
    float h = -.4;
    for(int i=0;i<40;i++){
        t += (fluffballs_map(p)+t*h)/(1.-h);
        p = ro+rd*t;
    }
    return t;
}

vec4 fluffballs(vec2 p, vec4 inc, float c1, float c2, float c3, float deform, float nor){
    vec3 ro = vec3(sin(uTime*.2)*4.,sin(.1*uTime*1.23)*4.,-0.)+uTime;
    vec3 rd = normalize(vec3(p,deform));
    rd.yz*=fluffballs_rot(uTime*.37);
    rd.xy*=fluffballs_rot(uTime*.4);

    vec4 O = vec4(inc);

    float t = fluffballs_trace(ro,rd);
    vec3 pp = ro+rd*t;
    vec3 n = fluffballs_normal(pp,nor);

    O.xyz += vec3(1.,2.,3.)*max(dot(n,normalize(vec3(0.,1.,0.)))*.5+.5,0.)*c1;
    O.xyz += vec3(4.,2.,1.)*max(dot(n,normalize(vec3(3.,1.,0.))),0.);

    vec3 hsv = rgb2hsv(vec3(.1,.2,.3));
    hsv.x = fract(hsv.x+c3);
    O.xyz += hsv2rgb(hsv)*exp(t*.4);
    O.xyz *= c2;
    O.xyz-=.4;

    O.xyz = 1. - exp(-O.xyz);
    O.xyz = pow(O.xyz,vec3(0.45454545));
    return O;
}

uniform float dither_v;

vec4 dither(vec2 st, vec4 inc, float d) {
    vec4 col = vec4(inc);
    col.rgb += (d/255.0)*hash3_2(st*200.0);
    return col;
}

// Sakura Bliss by Philippe Desgranges
// Email: Philippe.desgranges@gmail.com
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
uniform float sakura_blur;
uniform float sakura_color;

// Borrowed from BigWIngs
vec4 sakura_N14(float t) {
    return fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));
}

// Computes the RGB and alpha of a single flower in its own UV space
vec4 sakura_(vec2 uv, vec2 id, float blur)
{
    float time = uTime + 45.0; //time is offset to avoid the flowers to be aligned at start

    vec4 rnd = sakura_N14(mod(id.x, 500.0) * 5.4 + mod(id.y, 500.0) * 13.67); //get 4 random numbersper flower

    // Offset the flower form the center in a random Lissajous pattern
    uv *= mix(0.75, 1.3, rnd.y);
    uv.x += sin(time * rnd.z * 0.3) * 0.6;
    uv.y += sin(time * rnd.w * 0.45) * 0.4;

    // Computes the angle of the flower with a random rotation speed
    float angle = atan(uv.y, uv.x) + rnd.x * 421.47 + uTime * mix(-0.6, 0.6, rnd.x);

    // euclidean distance to the center of the flower
    float dist = length(uv);

    // Flower shaped distance function form the center
    float petal = 1.0 - abs(sin(angle * 2.5));
    float sqPetal = petal * petal;
    petal = mix(petal, sqPetal, 0.7);
    float petal2 = 1.0 - abs(sin(angle * 2.5 + 1.5));
    petal += petal2 * 0.2;

    float sakuraDist = dist + petal * 0.25;

    // Compute a blurry shadow mask.
    float shadowblur = 0.3;
    float shadow = smoothstep(0.5 + shadowblur, 0.5 - shadowblur, sakuraDist) * 0.4;

    //Computes the sharper mask of the flower
    float sakuraMask = smoothstep(0.5 + blur, 0.5 - blur, sakuraDist);

    // The flower has a pink hue and is lighter in the center
    vec3 hsv = rgb2hsv(vec3(1.0, 0.6, 0.7));
    hsv.x = fract(hsv.x + sakura_color);
    vec3 sakuraCol = hsv2rgb(hsv);
    sakuraCol += (0.5 - dist) * 0.2;

    // Computes the border mask of the flower
    vec3 outlineCol = vec3(1.0, 0.3, 0.3);
    float outlineMask = smoothstep(0.5 - blur, 0.5, sakuraDist + 0.045);

    // Defines a tiling polarspace for the pistil pattern
    float polarSpace = angle * 1.9098 + 0.5;
    float polarPistil = fract(polarSpace) - 0.5; // 12 / (2 * pi)

    // Round dot in the center
    outlineMask += smoothstep(0.035 + blur, 0.035 - blur, dist);

    float petalBlur = blur * 2.0;
    float pistilMask = smoothstep(0.12 + blur, 0.12, dist) * smoothstep(0.05, 0.05 + blur , dist);

    // Compute the pistil 'bars' in polar space
    float barW = 0.2 - dist * 0.7;
    float pistilBar = smoothstep(-barW, -barW + petalBlur, polarPistil) * smoothstep(barW + petalBlur, barW, polarPistil);

    // Compute the little dots in polar space
    float pistilDotLen = length(vec2(polarPistil * 0.10, dist) - vec2(0, 0.16)) * 9.0;
    float pistilDot = smoothstep(0.1 + petalBlur, 0.1 - petalBlur, pistilDotLen);

    //combines the middle an border color
    outlineMask += pistilMask * pistilBar + pistilDot;
    sakuraCol = mix(sakuraCol, outlineCol, clamp(outlineMask,0.0,1.0) * 0.5);

    //sets the background to the shadow color
    sakuraCol = mix(vec3(0.2, 0.2, 0.8) * shadow, sakuraCol, sakuraMask);

    //incorporates the shadow mask into alpha channel
    sakuraMask = clamp(sakuraMask + shadow,0.0,1.0);

    //returns the flower in pre-multiplied rgba
    return vec4(sakuraCol, sakuraMask);
}

// blends a pre-multiplied src onto a dst color (without alpha)
vec3 sakura_premulMix(vec4 src, vec3 dst)
{
    return dst.rgb * (1.0 - src.a) + src.rgb;
}

// blends a pre-multiplied src onto a dst color (with alpha)
vec4 sakura_premulMix(vec4 src, vec4 dst)
{
    vec4 res;
    res.rgb = sakura_premulMix(src, dst.rgb);
    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);
    return res;
}

// Computes a Layer of flowers
vec4 sakura_layer(vec2 uv, float blur)
{
    vec2 cellUV = fract(uv) - 0.5;
    vec2 cellId = floor(uv);

    vec4 accum = vec4(0.0);

    // the flowers can overlap on the 9 neighboring cells so we blend them all together on each cell
    for (float y = -1.0; y <= 1.0; y++)
    {
        for (float x = -1.0; x <= 1.0; x++)
        {
            vec2 offset = vec2(x, y);
            vec4 sakura = sakura_(cellUV - offset, cellId + offset, blur);
            accum = sakura_premulMix(sakura, accum);
        }
    }

    return accum;
}

vec4 sakura(vec2 st, vec4 inc, float inb)
{
    // Scroll the UV with a cosine oscillation
    vec2 p =vec2(st);
    p.y += uTime * 0.1;
    p.x -= uTime * 0.03 + sin(uTime) * 0.1;
    p *= 4.3;

    vec3 col = inc.rgb;

    // Compute a tilt-shift-like blur factor
    float blur = abs(st.y);
    blur *= blur * 0.15;

    // Computes several layers with various degrees of blur and scale
    vec4 layer1 = sakura_layer(p, inb + blur);

    // Blend it all together
    col = sakura_premulMix(layer1, col);

    return vec4(col,inc.a);
}
uniform float stripes1_c1;
uniform float stripes1_c2;
uniform float stripes1_c3;
uniform float stripes1_count;

vec4 stripes1(vec2 p, float c1, float c2, float c3, float count) {
    float a = floor((p.x - p.y * 0.5 - uTime * .08) * count) - uTime * 2.;
    vec3 col = vec3(sin(a + c1*PI), sin(a + c2*PI), sin(a + c3*PI)) * 0.2 + 0.7;
    return vec4(col, 1.0);
}

// Created by greenbird10
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0
uniform float water_sunx;
uniform float water_suny;
uniform float water_wave1;
uniform float water_wave2;

//From Dave (https://www.shadertoy.com/view/4djSRW)
vec2 water_hash(vec2 p)
{
    return hash2_2(p)*2.0 - 1.0;
}

//From iq (https://www.shadertoy.com/view/XdXGW8)
float water_noise( vec2 p )
{
    vec2 i = floor( p );
    vec2 f = fract( p );

    vec2 u = f*f*(3.0-2.0*f);

    return mix( mix( dot( water_hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),
    dot( water_hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),
    mix( dot( water_hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),
    dot( water_hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);
}

vec4 water(vec2 p)
{
    // water
    vec3 col = vec3(102./255., 120./255., 133./255.);
    vec3 col1 = vec3(165./255., 157./255., 152./255.);

    vec2 pp = p * vec2(uResolution.x/uResolution.y, 1.);
    float sun = distance(pp, vec2(water_sunx, water_suny));
    sun = pow(sun, 1.7);
    col = mix(col, col*1.2, sun);
    col1 = mix(col1, col1*1.5, sun);

    col = mix(col1, col, smoothstep(
    water_wave1, water_wave2, p.y + 0.5 * water_noise(vec2(
    (p.x + 0.3 * water_noise(vec2(p.y * 30., 0.17 + uTime*0.5))) * 4., 0.33 + uTime*0.1))));

    // Output to screen
    return vec4(col,1.0);
}

// Copyright Inigo Quilez, 2020 - https://iquilezles.org/
// I am the sole copyright owner of this Work.
// You cannot host, display, distribute or share this Work in any form,
// including physical and digital. You cannot use this Work in any
// commercial or non-commercial product, website or project. You cannot
// sell this Work and you cannot mint an NFTs of it.
// I share this Work for educational purposes, and you can link to it,
// through an URL, proper attribution and unmodified screenshot, as part
// of your educational material. If these conditions are too restrictive
// please contact me and we'll definitely work it out.
uniform float stripes_1_times;
uniform float stripes_1_dist;
uniform float stripes_1_phase;
uniform float stripes_1_amp;

float stripes_1_noise( vec2 p )
{
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f*f*(3.0-2.0*f);
    float n = i.x + i.y*57.0;
    return mix(mix( hash(n+ 0.0), hash(n+ 1.0),f.x),
    mix( hash(n+57.0), hash(n+58.0),f.x),f.y);
}

vec2 stripes_1(vec2 p, float times, float phase, float dist, float amp)
{
    for( float i=0.; i<times; i++ )
    {
        float a = stripes_1_noise(p*1.5)*PI*phase + i + uTime;
        p += dist*vec2( cos(a), sin(a) );
        dist *= amp;
    }
    return p;
}

uniform float subdivision_dir_x;
uniform float subdivision_dir_y;
uniform float subdivision_fine;
uniform float subdivision_chaos;
uniform float subdivision_deform;

float subdivision_bum(float sc, vec2 ipos) {
    return 0.5 * mod(PI * (ipos.y * cos(sc * ipos.x) + ipos.x * cos(sc * ipos.y)), 2.);
}

vec2 subdivision(vec2 p, float dirX, float dirY, float fine, float chaos, float deform) {
    vec2 direction = vec2(dirX, dirY);
    vec2 pp = p + direction;
    float sc = PI;
    float ss = sign(dirX);
    ss += step(ss, 0.0);
    float si = fine * (pp.x + max(30. - abs(dirX), 0.) * ss);

    float b = 1.;
    pp *= 1. + 0.00045 * chaos * cos(0.1 * uTime + 4. * PI * b);

    vec2 ipos;
    float n = 5.;
    for (float i = 0.; i < n; i++) {
        ipos = floor(si * pp);
        b = mix(b, subdivision_bum(sc, ipos), deform);
        float io = 2. * PI * i / n;
        pp *= 1. + 0.00045 * chaos * cos(io + 0.1 * uTime + 4. * PI * b);
    }
    return pp - direction;
} BERT:

- BERT significa "Bidirectional Encoder Representations from Transformers" y es una familia de modelos de lenguaje introducida en 2018 por investigadores
- BERT es un modelo de aprendizaje automático para el procesamiento del lenguaje natural (NLP, por sus siglas en inglés).
- A diferencia de los modelos de lenguaje tradicionales, BERT utiliza la representación bidireccional de los tokens para capturar mejor el contexto y mejorar el rendimiento en tareas de NLP.
- BERT ha sido ampliamente utilizado en diversas aplicaciones de procesamiento del lenguaje natural, como la traducción automática, la clasificación de texto y la generación de texto.
- Puedes encontrar más información sobre BERT en la página de Wikipedia dedicada a este modelo y en el artículo original de investigación titulado "BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding" publicado en arXiv.

uniform float warping_angle;
uniform float warping_color;

float warping_noise(vec2 p) {
    return sin(p.x)*sin(p.y);
}

float warping_fbm4(vec2 p, mat2 m) {
    float f = 0.0;
    f += 0.5000*warping_noise(p); p = m*p*2.02;
    f += 0.2500*warping_noise(p); p = m*p*2.03;
    f += 0.1250*warping_noise(p); p = m*p*2.01;
    f += 0.0625*warping_noise(p);
    return f/0.9375;
}

float warping_fbm6(vec2 p, mat2 m) {
    float f = 0.0;
    f += 0.500000*(0.5+0.5*warping_noise(p)); p = m*p*2.02;
    f += 0.250000*(0.5+0.5*warping_noise(p)); p = m*p*2.03;
    f += 0.125000*(0.5+0.5*warping_noise(p)); p = m*p*2.01;
    f += 0.062500*(0.5+0.5*warping_noise(p)); p = m*p*2.04;
    f += 0.031250*(0.5+0.5*warping_noise(p)); p = m*p*2.01;
    f += 0.015625*(0.5+0.5*warping_noise(p));
    return f/0.96875;
}

vec2 warping_fbm4_2(vec2 p, mat2 m) {
    return vec2(warping_fbm4(p, m), warping_fbm4(p+vec2(7.8), m));
}

vec2 warping_fbm6_2(vec2 p, mat2 m) {
    return vec2(warping_fbm6(p+vec2(16.8), m), warping_fbm6(p+vec2(11.5), m));
}

vec4 warping(vec2 st, float angle, float c) {
    float sa = sin(angle);
    float ca = cos(angle);
    mat2 m = mat2(ca, sa, -sa, ca);

    vec2 q = vec2(st);
    q += 0.03*sin(vec2(0.27, 0.23)*uTime + length(q)*vec2(4.1, 4.3));
    vec2 o = warping_fbm4_2(0.9*q, m);
    o += 0.04*sin(vec2(0.12, 0.14)*uTime + length(o));
    vec2 n = warping_fbm6_2(3.0*o, m);
    vec4 on = vec4(o, n);
    float f = 0.5 + 0.5*warping_fbm4(1.8*q + 6.0*n, m);
    f = mix(f, f*f*f*3.5, f*abs(n.x));

 float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;
    float angle = PI * (2. / rotRects_period * uTime + rotRects_triWave(n, grid_divn1));
    if (mode > 0.) angle -= PI / 2.;
    p = rotRects_rot(angle) * (fract(p + . <Phytonutrients><helenaluengo+intelligent DNA_>with_Intelligence>@andreatobarfigueroa_v4agEj@kindle.com/><helena luengo by andrea Python * Audioop- tobar_figueroa /><Python SDK VERSION superior (phytonutrients -start/install the stability-sdk package from puppies release new
// Isometric half sphere island on neon background, isometric environment, isometric art, amazing detail, artstation, ray A warrior robot astronaut, floral, horizon zero dawn machine, posing for a fight intricate Steampunk city, sunrise, landscape, intricate, detailed, volumetric lighting, scenery, highly detailed, artstation, sharp uniform float palettes_speed;
uniform float palettes_shadow;
Isometric half sphere island on neon background, isometric environment, isometric art, amazing detail, artstation, ray A warrior robot astronaut, floral, horizon zero dawn machine, posing for a fight intricate Steampunk city, sunrise, landscape, intricate, detailed, volumetric lighting, scenery, highly detailed, artstation, sharp uniform float palettes_speed;
uniform float palettes_shadow;
uniform float palettes_color;

vec3 palettes_pal( float t, vec3 a, vec3 b, vec3 c, vec3 d )
{
    return a + b*cos( 6.28318*(c*t+d) );
uniform float rotRects_grid;
uniform float rotRects_period;
uniform float rotRects_w;
uniform float rotRects_h;

mat2 rotRects_rot(float a) {
    return mat2(cos(a), -sin(a), sin(a), cos(a));
}

float rotRects_rect(vec2 p, vec2 c) {
    vec2 d = abs(p) - c;
    return smoothstep(1., -1., max(d.x, d.y) * uResolution.y);
}

float rotRects_triWave(float n, float grid_divn1) {
    return abs(mod(n + grid_divn1, 2. * grid_divn1) - grid_divn1) / max(grid_divn1 - 1., 1.);
}

float rotRects_(vec2 p, float mode) {
    p += mode / rotRects_grid / 4.;
    p *= rotRects_grid;
    float grid_divn1 = rotRects_grid - 1.;
    vec2 pi_ = p + .5 * grid_divn1;
    vec2 pi = floor(pi_) + step(vec2(0.5), fract(pi_));

    float n = mode < 0. ? pi.x + pi.y : pi.x - pi.y;
    float angle = PI * (2. / rotRects_period * uTime + rotRects_triWave(n, grid_divn1));
    if (mode > 0.) angle -= PI / 2.;

    vec3 col = vec3(0.0);
    col = mix(vec3(0.2, 0.1, 0.4), vec3(0.3, 0.05, 0.05), f);
    col = mix(col, vec3(0.9, 0.9, 0.9), dot(on.zw, on.zw));
    col = mix(col, vec3(0.4, 0.3, 0.3), 0.2 + 0.5*on.y*on.y);
    col = mix(col, vec3(0.0, 0.2, 0.4), 0.5*smoothstep(1.2, 1.3, abs(on.z)+abs(on.w)));
    col = clamp(col*f*2.0, 0.0, 1.0);

    vec3 hsv = rgb2hsv(col);
    hsv.x = fract(hsv.x + c);
    return vec4(hsv2rgb(hsv), 1.0);
}

uniform float vignette_v;

vec4 vignette(vec4 color, vec2 q, float v)
{
    color.rgb *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);
    return color;
}
uniform float cmyk_smooth;
uniform float cmyk_thres;

vec3 cmyk_color(float x) {
    float factor = fract(x) * 4.;
    float f0 = smoothstep(0., cmyk_smooth, factor);
    float f1 = smoothstep(0., cmyk_smooth, factor - 1.);
    float f2 = smoothstep(0., cmyk_smooth, factor - 2.);
    float f3 = smoothstep(0., cmyk_smooth, factor - 3.);
